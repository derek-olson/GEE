var FB_buff = ee.FeatureCollection('ft:1evoQ9ZDFqzGXiG2COjauqpXy6RI4BIWu54cMUSID', 'geometry');
var OutImageName = "postDisturbance"
// This function masks the input with a threshold on the simple cloud score.
var cloudMask = function(img) {
  var cloudscore = ee.Algorithms.Landsat.simpleCloudScore(img).select('cloud');
  return img.mask(img.mask().and(cloudscore.lt(20)));
};

// Load a Landsat 5 image collection.
var collection = ee.ImageCollection('LANDSAT/LC8_L1T_TOA')
  // Filter to get only two years of data.
  .filterDate('2013-01-01', '2015-11-30')
  // Filter to get only imagery at a point of interest.
  .filterBounds(FB_buff)
  // Mask clouds by mapping the cloudMask function over the collection.
  .map(cloudMask)
  // Select NIR and red bands only.
  .select(['B5', 'B4'])
  // Sort the collection in chronological order.
  .sort('system:time_start', true);

// Get the first image, for a starting time reference.
var first = ee.Image(collection.first());
var start = ee.Date(first.get('system:time_start'));

// This function computes the predictors and the response from the input.
var makeVariables = function(image) {
  // Compute time of the image in fractional years relative to the start.
  var year = ee.Date(image.get('system:time_start')).difference(start, 'year');
  // Compute the season in radians, one cycle per year.
  var season = year.mod(1).multiply(2 * Math.PI);
  // Return an image of the predictors followed by the response.
  return image.select()
    .addBands(ee.Image(1))                  // 0. constant term
    .addBands(year)                         // 1. linear change
    .addBands(season.sin())                 // 2. seasonal change
    .addBands(season.cos())                 // 3. seasonal change
    .addBands(image.normalizedDifference()) // 4. response variable
    .toFloat();
};

// Define the axes of variation in the collection array.
var imageAxis = 0;
var bandAxis = 1;

// Convert the collection to an array.
var array = collection.map(makeVariables).toArray();

// Get slices of the array according to positions along the band axis.
var predictors = array.arraySlice(bandAxis, 0, 4);
var response = array.arraySlice(bandAxis, 4);

// Compute coefficients the hard way.
var coefficients1 = predictors.arrayTranspose().matrixMultiply(predictors)
  .matrixInverse().matrixMultiply(predictors.arrayTranspose())
    .matrixMultiply(response);

// Turn the results into a multi-band image.
var coefficientsImage = coefficients1
  // Get rid of the extra dimensions.
  .arrayProject([0])
  .arrayFlatten([
    ['constant', 'trend', 'sin', 'cos']
]);
Map.addLayer(coefficientsImage.select([1,2,3]),{'min':-0.2,'max':0.3},'coeffs')

// exportImage(coefficientsImage.float(), OutImageName+'_sc',
//       {'maxPixels': 3e9,
//         'region': FB_buff.geometry().bounds().getInfo().coordinates[0],
//         'crs':  'EPSG:26913',
//         'scale': 30
//       });
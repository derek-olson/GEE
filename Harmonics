/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var vizParamsCoeffs = {"opacity":1,"bands":["NDVI_sin_200_year","NDVI_cos_200_year","NDVI_year"],"min":-0.2,"max":0.3,"gamma":1};
/***** End of imports. If edited, may not auto-convert in the playground. *****/
//Main code body written by: Ian Housman, Karis Tenneson, and Carson Stam
//CloudScore function originally written by: Matt Hancher
//Cloud shift function originally written by: Gennadii Donchyts
//Adapted to snippet by Joshua Goldstein
//Last updated 8-Sept-16 by Joshua Goldstein

///////////////////////////////////////////////////////////////////////////////
//Function for acquiring Landsat TOA image collection
function getImageCollection(studyArea,startDate,endDate,startJulian,endJulian){
  var ls;var l4TOAs;var l5TOAs;var l7TOAs;var l8TOAs;var out;
  
  var sensorBandDictLandsatTOA =ee.Dictionary({L8 : ee.List([1,2,3,4,5,9,6]),
                        L7 : ee.List([0,1,2,3,4,5,7]),
                        L5 : ee.List([0,1,2,3,4,5,6]),
                        L4 : ee.List([0,1,2,3,4,5,6])
  });
  var bandNamesLandsatTOA = ee.List(['blue','green','red','nir','swir1','temp',
      'swir2']);

  l4TOAs = ee.ImageCollection('LANDSAT/LT4_L1T_TOA')
      .filterDate(startDate,endDate)
      .filter(ee.Filter.calendarRange(startJulian,endJulian))
      .filterBounds(studyArea)
      .select(sensorBandDictLandsatTOA.get('L4'),bandNamesLandsatTOA);
  
  l5TOAs = ee.ImageCollection('LANDSAT/LT5_L1T_TOA')
      .filterDate(startDate,endDate)
      .filter(ee.Filter.calendarRange(startJulian,endJulian))
      .filterBounds(studyArea)
      .select(sensorBandDictLandsatTOA.get('L5'),bandNamesLandsatTOA);
  
  l8TOAs = ee.ImageCollection('LANDSAT/LC8_L1T_TOA')
      .filterDate(startDate,endDate)
      .filter(ee.Filter.calendarRange(startJulian,endJulian))
      .filterBounds(studyArea)
      .select(sensorBandDictLandsatTOA.get('L8'),bandNamesLandsatTOA);

  l7TOAs = ee.ImageCollection('LANDSAT/LE7_L1T_TOA')
      .filterDate(startDate,endDate)
      .filter(ee.Filter.calendarRange(startJulian,endJulian))
      .filterBounds(studyArea)
      .select(sensorBandDictLandsatTOA.get('L7'),bandNamesLandsatTOA);
  
  ls = ee.ImageCollection(l4TOAs.merge(l5TOAs).merge(l7TOAs).merge(l8TOAs));
  out = ls;
  return out
}


///////////////////////////////////////////////////////////////////////////////
// A helper to apply an expression and linearly rescale the output.
// Used in the landsatCloudScore function below.
var rescale = function(img, exp, thresholds) {
  return img.expression(exp, {img: img})
      .subtract(thresholds[0]).divide(thresholds[1] - thresholds[0]);
};

///////////////////////////////////////////////////////////////////////////////
// Compute a cloud score and adds a band that represents the cloud mask.  
// This expects the input image to have the common band names: 
// ["red", "blue", etc], so it can work across sensors.
function landsatCloudScore(img) {
  // Compute several indicators of cloudiness and take the minimum of them.
  var score = ee.Image(1.0);
  // Clouds are reasonably bright in the blue band.
  score = score.min(rescale(img, 'img.blue', [0.1, 0.3]));
 
  // Clouds are reasonably bright in all visible bands.
  score = score.min(rescale(img, 'img.red + img.green + img.blue', [0.2, 0.8]));
   
  // Clouds are reasonably bright in all infrared bands.
  score = score.min(
      rescale(img, 'img.nir + img.swir1 + img.swir2', [0.3, 0.8]));

  // Clouds are reasonably cool in temperature.
  score = score.where(img.select(['temp']).mask(),score.min(rescale(img,
      'img.temp', [300, 290])));

  // However, clouds are not snow.
  var ndsi = img.normalizedDifference(['green', 'swir1']);
  score =  score.min(rescale(ndsi, 'img', [0.8, 0.6])).multiply(100).byte();
  score = score.lt(cloudThresh).rename('cloudMask');
  img = img.updateMask(img.mask().and(score));
  return img.addBands(score);
}

///////////////////////////////////////////////////////////////////////////////
//Function for finding dark outliers in time series.
//Original concept written by Carson Stam and adapted by Ian Housman.
//Adds a band that is a mask of pixels that are dark, and dark outliers.
function simpleTDOM2(collection,zScoreThresh,shadowSumThresh,dilatePixels){
  var shadowSumBands = ['nir','swir1'];
  
  //Get some pixel-wise stats for the time series
  var irStdDev = collection.select(shadowSumBands).reduce(ee.Reducer.stdDev());
  var irMean = collection.select(shadowSumBands).mean();
  
  //Mask out dark dark outliers
  collection = collection.map(function(img){
    var zScore = img.select(shadowSumBands).subtract(irMean).divide(irStdDev);
    var irSum = img.select(shadowSumBands).reduce(ee.Reducer.sum());
    var TDOMMask = zScore.lt(zScoreThresh).reduce(ee.Reducer.sum()).eq(2)
        .and(irSum.lt(shadowSumThresh)).not();
    TDOMMask = TDOMMask.focal_min(dilatePixels);
    return img.addBands(TDOMMask.rename('TDOMMask'));
  });
  
  return collection;
}

///////////////////////////////////////////////////////////////////////////////
//Function for wrapping cloud and shadow masking together.
//Assumes image has cloud mask band called "cloudMask" and a TDOM mask called 
//"TDOMMask".
function cloudProject(img,shadowSumThresh,dilatePixels,cloudHeights){
  
  //Get the cloud mask
  var cloud = img.select('cloudMask').not();
  cloud = cloud.focal_max(dilatePixels);
  cloud = cloud.updateMask(cloud);
  
  //Get TDOM mask
  var TDOMMask = img.select(['TDOMMask']).not();
  
  //Project the shadow finding pixels inside the TDOM mask that are dark and 
  //inside the expected area given the solar geometry
  //Find dark pixels
  var darkPixels = img.select(['nir','swir1','swir2'])
      .reduce(ee.Reducer.sum()).lt(shadowSumThresh);//.gte(1);
  
  //Get scale of image
  var nominalScale = cloud.projection().nominalScale();

  //Find where cloud shadows should be based on solar geometry
  //Convert to radians
  var meanAzimuth = img.get('SUN_AZIMUTH');
  var meanZenith = img.get('SUN_ELEVATION');
  var azR = ee.Number(meanAzimuth).multiply(Math.PI).divide(180.0)
      .add(ee.Number(0.5).multiply(Math.PI ));
  var zenR = ee.Number(0.5).multiply(Math.PI )
      .subtract(ee.Number(meanZenith).multiply(Math.PI).divide(180.0));
  
  //Find the shadows
  var shadows = cloudHeights.map(function(cloudHeight){
    cloudHeight = ee.Number(cloudHeight);
    var shadowCastedDistance = zenR.tan()
        .multiply(cloudHeight);//Distance shadow is cast
    var x = azR.cos().multiply(shadowCastedDistance)
        .divide(nominalScale).round();//X distance of shadow
    var y = azR.sin().multiply(shadowCastedDistance)
        .divide(nominalScale).round();//Y distance of shadow
    return cloud.changeProj(cloud.projection(), cloud.projection()
        .translate(x, y));
  });

  var shadow = ee.ImageCollection.fromImages(shadows).max();
 
  //Create shadow mask
  shadow = shadow.updateMask(shadow.mask().and(cloud.mask().not()));
  shadow = shadow.focal_max(dilatePixels);
  shadow = shadow.updateMask(shadow.mask().and(darkPixels).and(TDOMMask));

  //Combine the cloud and shadow masks
  var combinedMask = cloud.mask().or(shadow.mask()).eq(0);
  
  //Update the image's mask and return the image
  img = img.updateMask(img.mask().and(combinedMask));
  img = img.addBands(combinedMask.rename(['cloudShadowMask']));
  return img;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
Performs a harmonic time series analysis of an image collection for a 
dependent variable and returns a multi-band image of the harmonic coefficients

Written by Joshua Goldstein (joshuagoldstein@fs.fed.us) on 1-Sept-2016
Adapted from "Lab 6: Time series analysis" by Nicholas Clinton and David Saah:
(https://code.earthengine.google.com/287929f82b0c761ed9631bb91fd6901e)

Last update: 2-Sept-2016 by Joshua Goldstein
*/

function getHarmonics(collection,dependent,harmonics){
  // Make a list of harmonic frequencies to model.  
  // These also serve as band name suffixes.
  var harmonicFrequencies = ee.List.sequence(1, harmonics);
  
  // Function to get a sequence of band names for harmonic terms.
  var getNames = function(base, list) {
    return ee.List(list).map(function(i) { 
      return ee.String(base).cat(ee.Number(i).int());
    });
  };
  
  // Construct lists of names for the harmonic terms.
  var cosNames = getNames('cos_', harmonicFrequencies);
  var sinNames = getNames('sin_', harmonicFrequencies);
  
  // Independent variables.
  var independents = ee.List(['constant', 't'])
    .cat(cosNames).cat(sinNames);
  
  // Function to add a constant band.
  var addConstant = function(image) {
    return image.addBands(ee.Image(1));
  };

  // Function to add a time band.
  var addTime = function(image) {
    // Compute time in fractional years since the epoch.
    var date = ee.Date(image.get('system:time_start'));
    var years = date.difference(ee.Date('1970-01-01'), 'year');
    var timeRadians = ee.Image(years.multiply(2 * Math.PI));
    return image.addBands(timeRadians.rename('t').float());
  };
  
  // Function to compute the specified number of harmonics
  // and add them as bands.  Assumes the time band is present.
  var addHarmonics = function(freqs) {
    return function(image) {
      // Make an image of frequencies.
      var frequencies = ee.Image.constant(freqs);
      // This band should represent time in radians.
      var time = ee.Image(image).select('t');
      // Get the cosine terms.
      var cosines = time.multiply(frequencies).cos()
        .rename(cosNames);
      // Get the sin terms.
      var sines = time.multiply(frequencies).sin()
        .rename(sinNames);
      return image.addBands(cosines).addBands(sines);
    };
  };
  
  // Add constants, time, and harmonics to image
  var harmonicImages = collection
    .map(addConstant)
    .map(addTime)
    .map(addHarmonics(harmonicFrequencies));
  
  // The output of the regression reduction is a 4x1 array image.
  var harmonicTrend = harmonicImages
    .select(independents.add(dependent))
    .reduce(ee.Reducer.linearRegression(independents.length(), 1));

  // Turn the array image into a multi-band image of coefficients.
  var harmonicTrendCoefficients = harmonicTrend.select('coefficients')
    .arrayProject([0])
    .arrayFlatten([independents]);
  var harmonicTrendResiduals = harmonicTrend.select('residuals')
    .arrayGet(0);
    
  return [harmonicTrendCoefficients, harmonicTrendResiduals];
  
}

///////////////////////////////////////////////////////////////////////////////
/*
EXAMPLE: Putting all of the pieces together to create a cloud free image 
composite of the Mekong region.

User inputs:
studyArea: Study area

startYear: First year to include imagery from

endYear: Last year to include imagery from

startJulian: Starting Julian Date- Supports wrapping for tropics and 
    southern hemisphere
    
endJulian: Ending Julian date- Supports wrapping for tropics and 
    southern hemisphere
    
cloudThresh: If using the cloudScoreTDOMShift method-Threshold for cloud 
    masking (lower number masks more clouds.  Between 10 and 30 generally 
    works best)
    
dilatePixels: Number of pixels to buffer clouds and cloud 
    shadows by (1 or 2 generally is sufficient)
    
cloudHeights: Height of clouds to use to project cloud shadows

zScoreThresh: Threshold for cloud shadow masking- lower number masks out 
    less.  Between -0.8 and -1.2 generally works well
    
shadowSumThresh: Sum of IR bands to include as shadows within TDOM and the 
    shadow shift method (lower number masks out less)
    
vizParams: Options for map visualization
*/

//Load bounding box of kaibab plateau
var kaibab = ee.FeatureCollection('ft:1hnVlNKz6KmY8Ohl4DfwtUFNeiMe1l65PDiMmZMBS', 'geometry');

var studyArea = kaibab.geometry();
var startYear = 2013;
var endYear = 2015;
var startJulian = 1;
var endJulian = 365;

var cloudThresh = 20;
var dilatePixels = 2;
var cloudHeights = ee.List.sequence(200,5000,500);
var zScoreThresh = -0.8;
var shadowSumThresh = 0.35;
var vizParams = {'min': 0.05,'max': 0.5, 'bands':'swir1,nir,red', 
    'gamma':1.6};

// Prepare dates
if(startJulian > endJulian){endJulian = endJulian + 365}
var startDate = ee.Date.fromYMD(startYear,1,1).advance(startJulian,'day');
var endDate = ee.Date.fromYMD(endYear,1,1).advance(endJulian,'day');
print('Start and end dates:',startDate,endDate);

// Get Landsat 4,5,8,7 Image Collections
var ls = getImageCollection(studyArea,startDate,endDate,startJulian,endJulian);
//Map.addLayer(ls.median(),vizParams,'Landsat before masking composite',false);

// Compute a cloud score and mask clouds
ls = ls.map(landsatCloudScore);

// Find and mask out dark outliers
ls = simpleTDOM2(ls,zScoreThresh,shadowSumThresh,dilatePixels);

// Run cloud project to get the final cloud and shadow masked image collection
ls = ls.map(function(img){return cloudProject(img,shadowSumThresh,dilatePixels,
    cloudHeights)});
//Map.addLayer(ls.median(),vizParams,'Landsat Composite',false);
print(ls);

///////////////////////////////////////////////////////////////////////
// Example of performing harmonic analysis 
// Collection on the NDVI variable.
    
// The dependent variable we are modeling.
var dependent = 'NDVI';

// The number of cycles per year to model.
var harmonics = 1;

// Function to add an NDVI band, the dependent variable.
var addNDVI = function(image) {
  return image
    .addBands(image.normalizedDifference(['nir', 'red'])
    .rename('NDVI'))
    .float();
};

// Add NDVI 
var filteredImages = ls
  .map(addNDVI);

// Perform the harmonic analysis
var harmonicTrendResults = getHarmonics(filteredImages,dependent,harmonics);
var harmonicTrendCoefficients = harmonicTrendResults[0];
var harmonicTrendResiduals = harmonicTrendResults[1];

///////////////////////////////////////////
// Compute phase and amplitude.
var phase = harmonicTrendCoefficients.select('cos_1').atan2(
            harmonicTrendCoefficients.select('sin_1'));
            
var amplitude = harmonicTrendCoefficients.select('cos_1').hypot(
                harmonicTrendCoefficients.select('sin_1'));

// Use the HSV to RGB transform to display phase and amplitude
var rgb = phase.unitScale(-Math.PI, Math.PI).addBands(
          amplitude.multiply(2.5)).addBands(
          ee.Image(1)).hsvToRgb();

// add phase and aplitute as bands to harmonictrendCoefficents image and clip to kaibab
var htcClip = harmonicTrendCoefficients.addBands(phase.rename('phase')).addBands(amplitude.rename('amplitude')).addBands(harmonicTrendResiduals);
//Nolan, can you add in the harmonicTrendResiduals band here? Then export. Thanks!!

htcClip = htcClip.clip(kaibab);
print(htcClip);         

//Include data from FullFieldStructurePlotList points, with updated sample weights
//var fieldStructure = ee.FeatureCollection('ft:1LkdGmqdrQP85ixDvmWUpqS0j8w0T5GxwxUylOxon');

          
// Add data to the Map
//Map.centerObject(kaibab, 9);
Map.addLayer(kaibab, null, "Kaibab Plateau");
Map.addLayer(htcClip,{bands:['cos_1', 'sin_1']},'Cos and sin Harmonics');
Map.addLayer(htcClip,{bands:['constant']},'intercept');
Map.addLayer(htcClip,{bands:['t']},'time trend');
Map.addLayer(rgb, {}, 'phase (hue), amplitude (saturation)');
//Map.addLayer(fieldStructure, {}, 'Field Structure Plot List');


///////////////////////////////////////////
// Nolan, here is the cos, sin export. 
// before you run this, can you add in the phase and amplitude as bands to htcClip?
///////////////////////////////////////////
Export.image.toDrive({image: htcClip, description: 'HarmonicTrendCoefficients',maxPixels:1e13, crs:'EPSG:26913', scale:30, });

///////////////////////////////////////////
///////////////////////////////////////////
